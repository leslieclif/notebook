# Consumer-driven contracts (CDC) 
CDC is a concept and testing approach that embraces the perspective of multiple consumers that communicate with providers. Typically, testing tends to define API contracts from the provider's perspective. Through a registry of contracts, multiple consumers now have a voice to provide producers their expectations on how data should be exchanged between the consumers and producers.
    1. Set up a Pact Broker on Kubernetes
    1. Write a consumer that defines and publishes Pact contracts
    1. Deploy and run a few Spring Boot microservices on Kubernetes
    1. Connect microservices to a database and public data source
    1. Verify the consumer pacts against a producer
    1. Find API defects and fix them
## What is consumer-driven contract testing? 
The "consumer-driven" prefix simply states an additional philosophical position that advocates for better internal microservices design by putting the consumers of such APIs at the heart of the design process. Provider-driven APIs tend to be biased towards the data that is being exposed and the system that is exposing it. 
- [PACT](https://pactflow.io/blog/author/matt/)
```BASH
# Adding the Private Repo helmchart (Refer Chaos)
helm repo add twuni https://helm.twun.io
helm install registry twuni/docker-registry \
  --version 1.10.0 \
  --namespace kube-system \
  --set service.type=NodePort \
  --set service.nodePort=31500
export REGISTRY=2886795362-31500-kira01.environments.katacoda.com
curl $REGISTRY/v2/_catalog | jq
# Registry Proxy for localhost:5000
# Docker tags require the address of the registry to be in the tag.
# If we push and pull from the registry, the registry name tag must be the same when we are on the client or within Kubernetes. Within your cluster, the registry is available at localhost:5000. Use a port-forwarding command to make this client's localhost:5000 to be the same registry.
kubectl port-forward -n kube-system service/registry-docker-registry 5000:5000 > /dev/null &
# This port forwarding will run in the background for the remainder of this scenario.
# Now you can access the registry via localhost.
curl http://localhost:5000/v2/_catalog | jq .
# This means when you push to localhost:5000, your container images will be routed to the private registry running as a service on Kubernetes.

# But what happens in the Pod specification when you want to pull the image using the tag localhost:5000? 
# We can add a proxy that runs as a DaemonSet that will resolve localhost:5000 to the registry whenever a Pod requests a container from localhost:5000. Install the proxy.
helm repo add incubator https://charts.helm.sh/incubator
# With the added repo, install the proxy daemons.

helm install registry-proxy incubator/kube-registry-proxy \
  --version 0.3.2 \
  --namespace kube-system \
  --set registry.host=registry-docker-registry.kube-system \
  --set registry.port=5000 \
  --set hostPort=5000

# For mature environments, you would have an official host name with a load balancer and an ingress that would resolve to a hardened registry service, albeit still running on Kubernetes.

# You will use docker push commands and YAML container references both using localhost:5000.
```
## About the Application
```BASH
# Clone Source Code
git clone https://github.com/javajon/cdc-with-k8s
cd ~/cdc-with-k8s
tree -d -L 2

# In summary, the aggregator serves data combining the daily COVID-19 metrics with the world population. 
```
## Add Pact Broker
- The Pact broker is the key that enables separation between the consumers and producers. The pact broker is a registry, or a library, that serves the collections of contacts generated by the consumers during mock testing and referenced by the producers during verification.
```BASH
cd ~/cdc-with-k8s/cluster
# There are two Kubernetes manifest files that declare the Deployments for the Pact Broker and its associated Postgres database. 
kubectl apply -f pact-broker-postgres.yaml
kubectl apply -f pact-broker.yaml
# The database is used for storing the Pacts and is attached to a Persistent Volume (PV) reserved in this cluster.
# Open the Pact Broker web interface and observe its contents.
# The broker is essentially empty. It does have an Example App, but this is just a sample. 
```
## Generate Pact from Consumer
- With the Pact framework, it's the consumers that create the Pacts. Independent of the producers or any service, the consumers write testing code that creates conversations with local mocked services. The Mocks are the consumer's perspectives of how the producers should react to the consumer's requests.
- This particular consumer is written in Node.js. It also uses Jest - a delightful JavaScript Testing Framework with a focus on simplicity.
- [CDC with Jest and Pact](https://www.mariedrake.com/post/contract-testing-with-pact-js-and-jest)
```BASH
cd ~/cdc-with-k8s/pact
# Generate Pact Contracts
npm install
# Produce the two Pact files:
npm run test:consumer-a
npm run test:consumer-b
# Once complete, new Pact JSON files are in the pacts directory. Inspect one of the contract files:
cat pacts/consumer_a-aggregator.json | jq -C .

# Publish Pacts to Pact Broker
# Define access to the Pact Broker:
export PACT_BROKER_URL=https://2886795362-30111-kira01.environments.katacoda.com/
export BROKER_USERNAME=pactbroker
export BROKER_PASSWORD=pactbroker

# Publish the pact to the broker:
npm run publish:pact

# Verify the pact has been published to the Pact Broker.
```
- Run H2 Database
- A low-level container in this application is a small database that contains world population data. You will use it as a read-only datastore providing the populations for the countries of the world, as well as the populations and locations of major cities. 
- Provided in this example is a SQL script that will seed a relational database, so we need to create an "initContainer" that will run next to the H2 container and seed it with the country and city population data when it starts. 
- The InitContainer pattern is very common for ensuring Pods are in the correct state when started.
```BASH
cd ~/cdc-with-k8s/h2-seeder
# Take a look at the Dockerfile to see how when it runs is uses an H2 RunScript utility to inject the world.sql into the H2 database that is assumed to be local, in the same Pod.
docker build -t localhost:5000/$(basename $PWD):0.0.1 .
# During the image build you can safely ignore the TLS certificate validation not implemented
docker push localhost:5000/$(basename $PWD):0.0.1
curl $REGISTRY/v2/_catalog | jq
# Apply this manifest declaration to set up a Pod and Service for H2.
kubectl apply -f ../cluster/h2-world.yaml

# The H2 database serves a convenient web interface for you to interact with the database. When you are presented with the connection information just put in jdbc:h2:/h2-data/world for the JDBC driver URL and leave the username and password blank.

# Use the Connect button to enter the SQL explorer. Enter 
select * from country
```
- Run World Population Microservice
- This is a Spring Boot based Microservice that simply reads world population data from the H2 database using SQL select calls. It offers REST endpoints to get the populations from `/countries` and `/cities`. Data is provided in the JSON format.
```BASH
cd ~/cdc-with-k8s/world-pop
# Build Microservice Container Image
# Spring Boot with Gradle (or Maven) has a convenient task called bootBuildImage. Without having to write a Dockerfile this task will bundle the Java application into an optimized container image. Build and tag the microservice container image
./gradlew bootBuildImage --imageName=localhost:5000/$(basename $PWD):0.0.1
docker push localhost:5000/$(basename $PWD):0.0.1
curl $REGISTRY/v2/_catalog | jq

# Start Microservice
kubectl apply -f ../cluster/$(basename $PWD).yaml
# The microservice will be running in a moment.

# Verify Microservice
curl https://2886795296-30101-kira01.environments.katacoda.com/ping; echo
curl https://2886795296-30101-kira01.environments.katacoda.com/countries | jq .
curl https://2886795296-30101-kira01.environments.katacoda.com/cities | jq .
```
- Run COVID-19 Microservice
- This is a Spring Boot based Microservice that reads COVID-19 metrics from a public CSV file. This microservice offers REST endpoints to get the data from the /metrics. Data is provided in the JSON format.
```BASH
cd ~/cdc-with-k8s/covid-19
./gradlew bootBuildImage --imageName=localhost:5000/$(basename $PWD):0.0.1
docker push localhost:5000/$(basename $PWD):0.0.1
# Start Microservice
kubectl apply -f ../cluster/$(basename $PWD).yaml
kubectl get pods,deployments,services -l app=$(basename $PWD)
# Verify Microservice
curl https://2886795296-30102-kira01.environments.katacoda.com/ping; echo
curl https://2886795296-30102-kira01.environments.katacoda.com/metrics | jq .
```
- Run Aggregator Microservice
- This microservice is called the Aggregator as it follows the common architecture pattern of an aggregator. It provides a single API gateway to access the other two microservices: world-pop and covid-19. The data from the two other microservices are merged into responses where COVID-19 data is merged with population data. With population data, you can get visibility in infection rates based on per capita.
```BASH
cd ~/cdc-with-k8s/aggregator
./gradlew bootBuildImage --imageName=localhost:5000/$(basename $PWD):0.0.1
docker push localhost:5000/$(basename $PWD):0.0.1
curl $REGISTRY/v2/_catalog | jq
# Start Microservice
kubectl apply -f ../cluster/$(basename $PWD).yaml
# Verify Microservice
curl https://2886795296-30103-kira01.environments.katacoda.com/ping; echo
curl https://2886795296-30103-kira01.environments.katacoda.com/countries | jq .
# Get a single country.
curl https://2886795296-30103-kira01.environments.katacoda.com/countries/ind | jq .
# Get the top countries with the highest infections per capita:
curl https://2886795296-30103-kira01.environments.katacoda.com/countries/percapita | jq .
```
- Verify Application (Failed?)
- Now that everything is started let's verify the contracts against the actual service. 
```BASH
cd ~/cdc-with-k8s/aggregator
# Verify the pacts on the producer side:
./gradlew pactVerify
# You will see that the verification failed. This shows us that a consumer disagrees with the producer. This disagreement is fantastic because it's unveiling a defect before it rolls further to production.
# If you inspect all the percentCases fields from the producer, they are all zero:
curl https://2886795296-30103-kira01.environments.katacoda.com/countries/percapita | jq . | grep percentCases
# The consumer contracts all expect the percentage of infection values to be greater than zero. The consumer code is written with these rules.
`expect(Number(response[0].percentCases)).toBeGreaterThan(0.0);
percentCases: term({ generate: "0.3333", matcher: "^([0-9]*[1-9][0-9]*(\.[0-9]+)?|[0]+\.[0-9]*[1-9][0-9]*)$" }),`
# So for some reason, the producer is producing only zeros. A typical defect on any normal day.
```
- Make Correction
- The problem is in the producer (aggregator) code
```BASH
cd ~/cdc-with-k8s/aggregator
# Look at the code in models/Country.java:
sed -n '{;=;p}' src/main/java/com/dijure/aggregator/models/Country.java | sed "N;s/\n/ /g" | sed -n '65,70p;!d'
# There's the bugger... Someone left in some testing code with an experimentation comment!
# Find and remove the offending line:
OFFENDING_LINE=$(sed -n '\|population = 0;|=' src/main/java/com/dijure/aggregator/models/Country.java)
sed -i "${OFFENDING_LINE}d" src/main/java/com/dijure/aggregator/models/Country.java
# Verify the moth has been removed from the relay
```
- Verify Application
- Rebuild the new container with an increased SemVer number. We bump the patch value, since it's a bug fix
```BASH
./gradlew bootBuildImage --imageName=localhost:5000/$(basename $PWD):0.0.2
# Push the corrected container image to the private registry on your Kubernetes cluster
docker push localhost:5000/$(basename $PWD):0.0.2
# Patch the current deployment to use the new container version
kubectl patch deployment aggregator -p \
  '{"spec":{"template":{"spec":{"containers":[{"name":"aggregator","image":"localhost:5000/aggregator:0.0.2"}]}}}}'
# Verify
kubectl get pods,deployments,services -l app=$(basename $PWD)
# Finally, run the pactVerify task again, and let's see if that bug has been squashed:
./gradlew pactVerify
```
- This means that your producer agrees with the contracts independently generated by all its consumers.
