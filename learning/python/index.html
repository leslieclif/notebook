



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="https://leslieclif.github.io/notebook/learning/python/">
      
      
        <meta name="author" content="Leslie">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Python - Leslie's Online Notebook</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://leslieclif.github.io/notebook/" title="Leslie's Online Notebook" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Leslie's Online Notebook
            </span>
            <span class="md-header-nav__topic">
              
                Python
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

<nav class="md-tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../.." title="Home" class="md-tabs__link">
          Home
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../server/" title="Server" class="md-tabs__link">
          Server
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../k8s/" title="Kubernetes" class="md-tabs__link">
          Kubernetes
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../ide/" title="IDE" class="md-tabs__link">
          IDE
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../ansible/" title="Learning" class="md-tabs__link">
          Learning
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://leslieclif.github.io/notebook/" title="Leslie's Online Notebook" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Leslie's Online Notebook
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Home
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Home
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../.." title="Welcome" class="md-nav__link">
      Welcome
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Server
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Server
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../server/" title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../server/install/" title="Installation" class="md-nav__link">
      Installation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../server/mobile/" title="Mobile" class="md-nav__link">
      Mobile
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Kubernetes
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Kubernetes
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../k8s/" title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../k8s/install/" title="Installation" class="md-nav__link">
      Installation
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      IDE
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        IDE
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../ide/" title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../ide/markdown/" title="Markdown" class="md-nav__link">
      Markdown
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Learning
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Learning
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../ansible/" title="Ansible" class="md-nav__link">
      Ansible
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>Python</h1>
                
                <div class="highlight"><pre><span></span># Range and For
for index in range(6):
    print(index)
# Range function is used generate a sequence of integers
index = range(10, -1, -1) # start, stop and setp, stops at 0 not including -1
# set class provides a mapping of unique immutable elements
# One use of set is to remove duplicate elements
dup_list = (&#39;c&#39;, &#39;d&#39;, &#39;c&#39;, &#39;e&#39;)
beta = set(dup_list)
uniq_list = list(beta) 
# dict class is an associative array of keys and values. keys must be unique immutable objects
dict_syn = {&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;}
dict_syn = dict(k1=&#39;v1&#39;, k2=&#39;v2&#39;)
dict_syn[&#39;k3&#39;] = &#39;v3&#39;  # adding new key value
del(dict_syn[&#39;k3&#39;])  # delete key value
print(dict_syn.keys()) # prints all keys
print(dict_syn.values()) # prints all values
# User Input
name = input(&#39;Name :&#39;)
# Functions
* A function is a piece of code, capable of performing a similar task repeatedly.
* It is defined using **def** keyword in python.
def &lt;function_name&gt;(&lt;parameter1&gt;, &lt;parameter2&gt;, ...):
     &#39;Function documentation&#39;
     function_body
     return &lt;value&gt;  
* Parameters, return expression and documentation string are optional.
def square(n):
    &quot;Returns Square of a given number&quot;
    return n**2

print(square.__doc__)   //prints the function documentation string
* 4 types of arguments
* Required Arguments: non-keyword arguments
def showname(name, age)

showname(&quot;Jack&quot;, 40)  // name=&quot;Jack&quot;, age=40
showname(40, &quot;Jack&quot;)  // name=40, age=&quot;Jack&quot;
* Keyword Arguments: identified by paramater names
def showname(name, age)

showname(age=40, name=&quot;Jack&quot;)
* Default Arguments: Assumes a default argument, if an arg is not passsed.
def showname(name, age=50)

showname(&quot;Jack&quot;)              // name=&quot;Jack&quot;, age=50
showname(age=40,&quot;Jack&quot;)       // name=&quot;Jack&quot;, age=40
showname(name=&quot;Jack&quot;, age=40) // name=&quot;Jack&quot;, age=40
showname(name=&quot;Jack&quot;, 40)   // Python does not allow passing non-keyword after keyword arg. This will fail.
* Variable Length Arguments: Function preocessed with more arguments than specified while defining the function
def showname(name, *vartuple, **vardict)
# *vartuple = Variable non keyword argument which will be a tuple. Denoted by *
# **vardict = Variable keyword argument which will be a dictionary. Denoted by **
showname(&quot;Jack&quot;)                              // name=&quot;Jack&quot;
showname(&quot;Jack&quot;, 35, &#39;M&#39;, &#39;Kansas&#39;)           // name=&quot;Jack&quot;, *vartuple=(35, &#39;M&#39;, &#39;Kansas&#39;)
showname(&quot;Jack&quot;, 35, city=&#39;Kansas&#39;, sex=&#39;M&#39;)  // name=&quot;Jack&quot;, *vartuple=(35), **vardict={city=&#39;Kansas&#39;, sex=&#39;M&#39;}
# An Iterator is an object, which allows a programmer to traverse through all the elements of a collection, regardless of its specific implementation.
x = [6, 3, 1]
s = iter(x)            
print(next(s))      # -&gt; 6
# List Comprehensions -&gt; Alternative to for loops.
* More concise, readable, efficient and mimic functional programming style.
* Used to: Apply a method to all or specific elements of a list, and Filter elements of a list satisfying specific criteria.
x = [6, 3, 1]
y = [ i**2 for i in x ]   # List Comprehension expression
print(y)              # -&gt; [36, 9, 1] 
* Filter positive numbers (using for and if)
vec = [-4, -2, 0, 2, 4]
pos_elm = [x for x in vec if x &gt;= 0]  # Can be read as for every elem x in vec, filter x if x is greater than or equal to 0
print(pos_elm)         # -&gt; [0, 2, 4]
* Applying a method to a list
def add10(x):
    return x + 10

n = [34, 56, 75, 3]
mod_n = [ add10(num) for num in n]
print(mod_n)
# A Generator is a function that produces a sequence of results instead of a single value
def arithmatic_series(a, r):
    while a &lt; 50:
        yield a  # yield is used in place of return which suspends processing
        a += r

s = arithmatic_series(3, 10)
# Execution of further &#39;arithmetic series&#39; can be resumed only by calling nextfunction again on generator &#39;s&#39;
print(s)   //Generator #output=3
print(next(s))  //Generator starts execution  # output=13
print(next(s))  //resumed # output=23
# A Generator expresions are generator versions of list comprehensions. They return a generator instead of a list.
x = [6, 3, 1]
g = (i**2 for i in x)  # generator expression
print(next(g))         # -&gt; 36
# Dictionary Comprehensions -&gt; takes the form {key: value for (key, value) in iterable}
myDict = {x: x**2 for x in [1,2,3,4,5]} 
print (myDict)    # Output {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
# Calculate the frequency of each identified unique word in the list
words = [&#39;Hello&#39;, &#39;Hi&#39;, &#39;Hello&#39;]
freq = { w:words.count(w) for w in words }
print(freq)    # Output {&#39;Hello&#39;: 2, &#39;Hi&#39;: 1}
Create the dictionary frequent_words, which filter words having frequency greater than one
words = [&#39;Hello&#39;, &#39;Hi&#39;, &#39;Hello&#39;]
freq = { w:words.count(w) for w in words if words.count(w) &gt; 1 }
print(freq)   # Output {&#39;Hello&#39;: 2}
# Defining Classes
* Syntax
class &lt;ClassName&gt;(&lt;parent1&gt;, ... ):
    class_body
# Creating Objects
* An object is created by calling the class name followed by a pair of parenthesis.
class Person:             
    pass                    
p1 = Person()      # Creating the object &#39;p1&#39;
print(p1)          # -&gt; &#39;&lt;__main__.Person object at 0x0A...&gt;&#39; # tells you what class it belongs to and hints on memory address it is referenced to.
# initializer method -&gt; __init__ 
*  defined inside the class and called by default, during an object creation.
* It also takes self as the first argument, which refers to the current object.
class Person:
    def __init__(self, fname, lname):
        self.fname = fname
        self.lname = lname
p1 = Person(&#39;George&#39;, &#39;Smith&#39;)   
print(p1.fname, &#39;-&#39;, p1.lname)           # -&gt; &#39;George - Smith&#39;
# Documenting a Class
* Each class or a method definition can have an optional first line, known as docstring.
class Person:
    &#39;Represents a person.&#39;
# Inheritance
* Inheritance describes is a kind of relationship between two or more classes, abstracting common details into super class and storing specific ones in the subclass.
* To create a child class, specify the parent class name inside the pair of parenthesis, followed by it&#39;s name. 
class Child(Parent):  
   pass
* Every child class inherits all the behaviours exhibited by their parent class.
* In Python, every class uses inheritance and is inherited from **object** by default.
class MySubClass(object):     # object is known as parent or super class.
    pass   
# Inheritance in Action
class Person:
    def __init__(self, fname, lname):
        self.fname = fname
        self.lname = lname
class Employee(Person):
    all_employees = []
    def __init__(self, fname, lname, empid):
        Person.__init__(self, fname, lname)  # Employee class utilizes __init __ method of the parent class Person to create its object.
        self.empid = empid
        Employee.all_employees.append(self)

e1 = Employee(&#39;Jack&#39;, &#39;simmons&#39;, 456342) 
print(e1.fname, &#39;-&#39;, e1.empid)   # Output -&gt; Jack - 456342  
# Polymorphism
* Polymorphism allows a subclass to override or change a specific behavior, exhibited by the parent class
class Employee(Person):
    all_employees = EmployeesList ()
    def __init__(self, fname, lname, empid):
        Person.__init__(self, fname, lname)
        self.empid = empid
        Employee.all_employees.append(self)
    def getSalary(self):
        return &#39;You get Monthly salary.&#39;
    def getBonus(self):
        return &#39;You are eligible for Bonus.&#39;
* Definition of ContractEmployee class derived from Employee. It overrides functionality of getSalary and getBonus methods found in it&#39;s parent class Employee.
class ContractEmployee(Employee):
   def getSalary(self):
        return &#39;You will not get Salary from Organization.&#39;
    def getBonus(self):
        return &#39;You are not eligible for Bonus.&#39;

e1 = Employee(&#39;Jack&#39;, &#39;simmons&#39;, 456342)
e2 = ContractEmployee(&#39;John&#39;, &#39;williams&#39;, 123656)
print(e1.getBonus())    # Output - You are eligible for Bonus.
print(e2.getBonus())    # Output - You are not eligible for Bonus.
# Abstraction
* Abstraction means working with something you know how to use without knowing how it works internally.
* It is hiding the defaults and sharing only necessary information.
# Encapsulation
* Encapsulation allows binding data and associated methods together in a unit i.e class.
* Bringing related data and methods inside a class to avoid misuse outside. 
* These principles together allows a programmer to define an interface for applications, i.e. to define all tasks the program is capable to execute and their respective input and output data.
* A good example is a television set. We don’t need to know the inner workings of a TV, in order to use it. All we need to know is how to use the remote control (i.e the interface for the user to interact with the TV).
# Abstracting Data
* Direct access to data can be restricted by making required attributes or methods private, **just by prefixing it&#39;s name with one or two underscores.**
* An attribute or a method starting with:
+ **no underscores** is a **public** one.
+ **a single underscore** is **private**, however, still accessible from outside.
+ **double underscores** is **strongly private** and not accessible from outside.
# Abstraction and Encapsulation Example
* **empid** attribute of Employee class is made private and is accessible outside the class only using the method **getEmpid**.
class Employee(Person):
    all_employees = EmployeesList()
    def __init__(self, fname, lname, empid):
        Person.__init__(self, fname, lname)
        self.__empid = empid
        Employee.all_employees.append(self)
    def getEmpid(self):
        return self.__empid

e1 = Employee(&#39;Jack&#39;, &#39;simmons&#39;, 456342)
print(e1.fname, e1.lname)         # Output -&gt; Jack simmons
print(e1.getEmpid())              # Output -&gt; 456342
print(e1.__empid)                 # Output -&gt; AttributeError: Employee instance has no attribute &#39;__empid&#39;
# Exceptions
* Python allows a programmer to handle such exceptions using **try ... except** clauses, thus avoiding the program to crash.
* Some of the python expressions, though written correctly in syntax, result in error during execution. **Such scenarios have to be handled.**
* In Python, every error message has two parts. The first part tells what type of exception it is and second part explains the details of error.
# Handling Exception
* A try block is followed by one or more except clauses.
* The code to be handled is written inside try clause and the code to be executed when an exception occurs is written inside except clause.
try:
    a = pow(2, 4)
    print(&quot;Value of &#39;a&#39; :&quot;, a)
    b = pow(2, &#39;hello&#39;)   # results in exception
    print(&quot;Value of &#39;b&#39; :&quot;, b)
except TypeError as e:
    print(&#39;oops!!!&#39;)
print(&#39;Out of try ... except.&#39;)
Output -&gt; Value of &#39;a&#39; : 16 --&gt; oops!!! --&gt; Out of try ... except.
# Raising Exceptions
* **raise** keyword is used when a programmer wants a specific exception to occur.
try:
    a = 2; b = &#39;hello&#39;
    if not (isinstance(a, int)
            and isinstance(b, int)):
        raise TypeError(&#39;Two inputs must be integers.&#39;)
    c = a**b
except TypeError as e:
    print(e)
# User Defined Exception Functions
* Python also allows a programmer to create custom exceptions, derived from base Exception class.
class CustomError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return str(self.value)

try:
    a = 2; b = &#39;hello&#39;
    if not (isinstance(a, int)
            and isinstance(b, int)):
        raise CustomError(&#39;Two inputs must be integers.&#39;) # CustomError is raised in above example, instead of TypeError.
   c = a**b
except CustomError as e:
    print(e)
# Using &#39;finally&#39; clause
* **finally** clause is an optional one that can be used with try ... except clauses.
* All the statements under finally clause are executed irrespective of exception occurrence.
def divide(a,b):
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        print(&quot;Dividing by Zero.&quot;)
    finally:
        print(&quot;In finally clause.&quot;)    # Statements inside finally clause are ALWAYS executed before the return back 
# Using &#39;else&#39; clause
* **else** clause is also an optional clause with try ... except clauses.
* Statements under else clause are executed **only when no exception occurs in try clause**.
try:
    a = 14 / 7
except ZeroDivisionError:
    print(&#39;oops!!!&#39;)
else:
    print(&#39;First ELSE&#39;)
try:
    a = 14 / 0
except ZeroDivisionError:
    print(&#39;oops!!!&#39;)
else:
    print(&#39;Second ELSE&#39;)
Output: First ELSE --&gt; oops!!!
# Module
* Any file containing logically organized Python code can be used as a module.
* A module generally contains **any of the defined functions, classes and variables**. A module can also include executable code.
* Any Python source file can be used as a module by using an import statement in some other Python source file.
# Packages
* A package is a collection of modules present in a folder. 
* The name of the package is the name of the folder itself. 
* A package generally contains an empty file named **__init__.py** in the same folder, which is required to treat the folder as a package.
# Import Modules
import math         # Recommended method of importing a module
import math as m
from math import pi, tan
from math import pi as pie, tan as tangent
# Working with Files
* Data from an opened file can be read using any of the methods: **read, readline and readlines**.
* Data can be written to a file using either **write** or **writelines** method.
* A file **must be opened**, before it is used for reading or writing.
fp = open(&#39;temp.txt&#39;, &#39;r&#39;)   # opening ( operations &#39;r&#39; &amp; &#39;w&#39;)
content = fp.read()          # reading
fp.close()                   # closing
# read() -&gt; Reads the entire contents of a file as bytes. 
# readline() -&gt; Reads a single line at a time.
# readlines() -&gt; Reads a all the line  &amp; each line is stored as an element of a list.
# write() -&gt; Writes a single string to output file.
# writelines() -&gt; Writes multiple lines to output file &amp; each string is stored as an element of a list. 
* Reading contents of file and storing as a dictionary
fp = open(&#39;emp_data.txt&#39;, &#39;r&#39;)
emps = fp.readlines()
# Preprocessing data
emps = [ emp.strip(&#39;\n&#39;) for emp in emps ]
emps = [ emp.split(&#39;;&#39;) for emp in emps ] 
header = emps.pop         # remove header record separately
emps = [ dict(zip(header, emp) for emp in emps ]   # header record is used to combine with data to form a dictionary

print(emps[:2])   # prints first 2 records

* Filtering data based on criteria
fil_emps = [emp[&#39;Emp_name&#39;] for emp in emps if emp[&#39;Emp_work_location&#39;]==&#39;HYD&#39;]
* Filtering data based on pattern
import re
pattern = re.compile(r&#39;oracle&#39;, re.IGNORECASE)  # Regular Expression
oracle_emps = [emp[&#39;Emp_name&#39;] for emp in emps if pattern.search(emp[&#39;Emp_skillset&#39;])]
* Filter and Sort data in ascending order
fil_emps = [emp for emp in emps if emp[&#39;Emp_designation&#39;]==&#39;ASE&#39;]
fil_emps = sorted(fil_emps, key=lambda k: k[&#39;Emp_name&#39;])
print(emp[&#39;Emp_name&#39;] for emp in fil_emps )
* Sorting all employees based on custom sorting criteria
order = {&#39;ASE&#39;: 1, &#39;ITA&#39;: 2, &#39;AST&#39;: 3}
sorted_emp = sorted(emp, key=lambda k: order[k[&#39;designation&#39;]])
* Filter data and write into files
fil_emps = [emp for emp in emps if emp[&#39;Emp_Designation&#39;] == &#39;ITA&#39;]
ofp = open(outputtext.txt, &#39;w&#39;)
keys = fil_emps[0].keys()  # Remove header from key name
for key in keys:
    ofp.write(key+&quot;\t&quot;)
ofp.write(&quot;\n&quot;)
for emp in fil_emps:
    for key in keys:
        ofp.write(emp[key]+&quot;\t&quot;)
    ofp.write(&quot;\n&quot;)
ofp.close()
# Regular Expressions
* Regex are useful to construct patterns that helps in filtering the text possessing the pattern.
* **re module** is used to deal with regex.
* **search** method takes pattern and text to scan  and returns a Match object. Return None if not found.
* Match object holds info on the nature of the match like **original input string, Regular expression used, location within the original string**
match = re.search(pattern, text)
start_index = match.start()  # start location of match
end_index = match.end()
regex = match.re.pattern()
print(&#39;Found &quot;{}&quot; pattern in &quot;{}&quot; from {} to {}&#39;.format(st, text, start_index, end_index))
# Compiling Expressions
* In Python, its more efficient t compile the patterns that are frequently used.
* **compile** function of re module converts an expression string into a **RegexObject**.
patterns = [&#39;this&#39;, &#39;that&#39;]
regexes = [re.compile(p) for p in patterns]
for regex in regexes:
    if regex.search(text):   # pattern is not required
        print(&#39;Match found&#39;)
* search method only returns the first matching occurrence.
# Finding Multiple Matches
* findall method returns all the substrings of the pattern without overlapping
pattern= &#39;ab&#39;
for match in re.findall(pattern, text):
    print(&#39;match found - {}&#39;.format(match))
# Grouping Matches
* Adding groups to a pattern enables us to isolate parts of the matching text, expanding those capabilities to create a parser.
* Groups are defined by enclosing patterns within parenthesis
text= &#39;This is some text -- with punctuations.&#39;
for pattern in [r&#39;^(\w+)&#39;,                  # word at the start of the string
                r&#39;(\w+)\S*$&#39;,               # word at the end of the string with punctuation
                r&#39;(\bt\w+)\W+(\w+)&#39;,        # word staring with &#39;t&#39; and the next word
                r&#39;(\w+t)\b&#39;]:               # word ending with t
    regex = re.compile(pattern)
    match = regex.search(text)
    print(match.groups())                   # Output -&gt; (&#39;This&#39;,) (&#39;punctuations&#39;,) (&#39;text&#39;,&#39;with&#39;) (&#39;text&#39;,)
# Naming Grouped Matches
* Accessing the groups with defined names
text= &#39;This is some text -- with punctuations.&#39;
for pattern in [r&#39;^(?P&lt;first_word&gt;\w+)&#39;,                  # word at the start of the string
                r&#39;(?P&lt;last_word&gt;\w+)\S*$&#39;,                # word at the end of the string with punctuation
                r&#39;(?P&lt;t_word&gt;\bt\w+)\W+(?P&lt;other_word&gt;\w+)&#39;,  # word staring with &#39;t&#39; and the next word
                r&#39;(?P&lt;ends_with_t&gt;\w+t)\b&#39;]:              # word ending with t
    regex = re.compile(pattern)
    match = regex.search(text)
    print(&quot;Groups: &quot;,match.groups())                 # Output -&gt; (&#39;This&#39;,) (&#39;punctuations&#39;,) (&#39;text&#39;,&#39;with&#39;) (&#39;text&#39;,)
    print(&quot;Group Dictionary: &quot;,match.groupdict())    # Output -&gt; {&#39;first_word&#39;:&#39;This&#39;} {&#39;last_word&#39;: &#39;punctuations&#39;} {&#39;t_word&#39;:&#39;text&#39;, &#39;other_word&#39;:&#39;with&#39;} {&#39;ends_with_t&#39;:&#39;text&#39;}
# Data Handling
# Handling XML files
* **lxml** 3rd party module is a highly feature rich with ElementTree API and supports querying wthe xml content using XPATH.
* In the ElementTree API, an element acts like a list. The items of the list are the elements children.
* XML search is faster in lxml.
&lt;?xml&gt;
&lt;employee&gt;
    &lt;skill name=&quot;Python&quot;/&gt;
&lt;/employee&gt;
from lxml import etree
tree = etree.parse(&#39;sample.xml&#39;)
root = tree.getroot()  # gets doc root &lt;?xml&gt;
skills = tree.findall(&#39;//skill&#39;)  # gets all skill tags
for skill in skills:
    print(&quot;Skills: &quot;, skill.attrib[&#39;name&#39;])
# Adding new skill in the xml
skill = etree.SubElement(root, &#39;skill&#39;, attrib={&#39;name&#39;:&#39;PHP&#39;})
# Handling HTML files
* **lxml** 3rd party module is used for parsing HTML files as well.
import urllib.request
from lxml import etree
def readURL(url):
    urlfile = urllib.request.urlopen(url)
    if urlfile.getcode() == 200:
        contents = urlfile.read()
        return contents
if __name__ == &#39;__main__&#39;:
    url = &#39;http://xkcd.com&#39;
    html = readURL(url)
# Data Serialization
* Process of converting **data types/objects** into **Transmittable/Storable** format is called Data Serialization.
* In python, **pickle and json** modules are used for Data Serialization.
* Serialized data can then be written to file/Socket/Pipe. From these it can be de-serialized and stored into a new Object.
json.dump(data, file, indent=2)  # serialized data is written to file with indentation using dump method
data_new = json.load(file)       # de-serialized data is written to new object using load method
# Database Connectivity
* **Python Database API (DB-API)** is a standard interface to interact with various databases.
* Different DB API’s are used for accessing different databases. Hence a programmer has to install DB API corresponding to the database one is working with.
* Working with a database includes the following steps:
    + Importing the corresponding DB-API module.
    + Acquiring a connection with the database.
    + Executing SQL statements and stored procedures.
    + Closing the connection
import sqlite3
# establishing  a database connection
con = sqlite3.connect(&#39;D:\\TEST.db&#39;)
# preparing a cursor object
cursor = con.cursor()
# preparing sql statements
sql1 = &#39;DROP TABLE IF EXISTS EMPLOYEE&#39;
# closing the database connection
con.close()
# Inserting Data
* Single rows are inserted using **execute** and multiple rows using **executeMany** method of created cursor object.
# preparing sql statement
rec = (456789, &#39;Frodo&#39;, 45, &#39;M&#39;, 100000.00)
sql = &#39;&#39;&#39;
      INSERT INTO EMPLOYEE VALUES ( ?, ?, ?, ?, ?)
      &#39;&#39;&#39;
# executing sql statement using try ... except blocks
try:
    cursor.execute(sql, rec)
    con.commit()
except Exception as e:
    print(&quot;Error Message :&quot;, str(e))
    con.rollback()
# Fetching Data
* **fetchone**: It retrieves one record at a time in the form of a tuple.
* **fetchall**: It retrieves all fetched records at a point in the form of tuple of tuples.
# fetching the records
records = cursor.fetchall()
# Displaying the records
for record in records:
    print(record)
# Object Relational Mappers
* An object-relational mapper (ORM) is a library that automates the transfer of data stored in relational database tables into objects that are adopted in application code.
* ORMs offer a high-level abstraction upon a relational database, which permits a developer to write Python code rather than SQL to create, read, update and delete data and schemas in their database.
* Such an ability to write Python code instead of SQL speeds up web application development.
# Higher Order Functions
* A **Higher Order function** is a function, which is capable of doing any one of the following things:
+ It can be functioned as a **data** and be assigned to a variable.
+ It can accept any other **function as an argument**.
+ It can return a **function as its result**.
*The ability to build Higher order functions, **allows a programmer to create Closures, which in turn are used to create Decorators**.
# Function as a Data
def greet():
    return &#39;Hello Everyone!&#39;
print(greet())
wish = greet        # &#39;greet&#39; function assigned to variable &#39;wish&#39;
print(type(wish))   # Output -&gt; &lt;type &#39;function&#39;&gt;
print(wish())       # Output -&gt; Hello Everyone!
# Function as an Argument
def add(x, y):
    return x + y
def sub(x, y):
   return x - y
def prod(x, y):
    return x * y
def do(func, x, y):
   return func(x, y)
print(do(add, 12, 4))   # &#39;add&#39; as arg # Output -&gt; 16
print(do(sub, 12, 4))   # &#39;sub&#39; as arg # Output -&gt; 8
print(do(prod, 12, 4))  # &#39;prod&#39; as arg # Output -&gt; 48
# Returning a Function
def outer():
    def inner():
        s = &#39;Hello world!&#39;
        return s            

    return inner()   

print(outer()) # Output -&gt; Hello world!
* You can observe from the output that the **return value of &#39;outer&#39; function is the return value of &#39;inner&#39; function** i.e &#39;Hello world!&#39;.

def outer():
    def inner():
        s = &#39;Hello world!&#39;
        return s            

    return inner   # Removed &#39;()&#39; to return &#39;inner&#39; function itself   

print(outer()) #returns &#39;inner&#39; function  # Output -&gt; &lt;function inner at 0xxxxxx&gt;
func = outer() 
print(type(func))     # Output -&gt; &lt;type &#39;function&#39;&gt;
print(func()) # calling &#39;inner&#39; function  # Output -&gt; Hello world!
* Parenthesis after the **inner** function are removed so that the **outer** function returns **inner function**.
# Closures
* A Closure is a **function returned by a higher order function**, whose return value depends on the data associated with the higher order function.
def multiple_of(x):
    def multiple(y):
        return x*y
    return multiple
c1 = multiple_of(5)  # &#39;c1&#39; is a closure
c2 = multiple_of(6)  # &#39;c2&#39; is a closure
print(c1(4)) # Output -&gt; 5 * 4 = 20
print(c2(4)) # Output -&gt; 6 * 4 = 24
* The first closure function, c1 binds the value 5 to argument x and when called with an argument 4, it executes the body of multiple function and returns the product of 5 and 4.
* Similarly c2 binds the value 6 to argument x and when called with argument 4 returns 24.
# Decorators
* Decorators are evolved from the concept of closures.
* A decorator function is a higher order function that takes a function as an argument and returns the inner function.
* A decorator is capable of adding extra functionality to an existing function, without altering it.
* The decorator function is prefixed with **@ symbol** and written above the function definition.
+ Shows the creation of closure function wish using the higher order function outer.
def outer(func):
    def inner():
        print(&quot;Accessing :&quot;, 
                  func.__name__)
        return func()
    return inner
def greet():
   print(&#39;Hello!&#39;)
wish = outer(greet)    # Output -&gt; Accessing : greet
wish()                 # Output -&gt; Hello!
    - wish is the closure function obtained by calling an outer function with the argument greet. When wish function is called, inner function gets executed.
+ The second one shows the creation of decorator function outer, which is used to decorate function greet.
def outer(func):
   def inner():
        print(&quot;Accessing :&quot;, 
                  func.__name__)
        return func()
    return inner
def greet():
   return &#39;Hello!&#39;
greet = outer(greet) # decorating &#39;greet&#39; # Output -&gt; No Output as return is used instead of print 
greet()  # calling new &#39;greet&#39;  # Output -&gt; Accessing : greet
    - The function returned by outer is assigned to greet i.e the function name passed as argument to outer. This makes outer a decorator to greet.
+ Third one displays decorating the greet function with decorator function, outer, using @ symbol.
def outer(func):
    def inner():
        print(&quot;Accessing :&quot;, 
                func.__name__)
        return func()
    return inner
@outer               # This is same as **greet = outer(greet)**
def greet():
    return &#39;Hello!&#39;
greet()          # Output -&gt; Accessing : greet
# Descriptors
* Python descriptors allow a programmer to create managed attributes.
* In other object-oriented languages, you will find **getter and setter** methods to manage attributes.
* However, Python allows a programmer to manage the attributes simply with the attribute name, without losing their protection.
* This is achieved by defining a **descriptor class**, that implements any of **__get__, __set__, __delete__** methods.
class EmpNameDescriptor:
    def __get__(self, obj, owner):
        return self.__empname
    def __set__(self, obj, value):
        if not isinstance(value, str):
            raise TypeError(&quot;&#39;empname&#39; must be a string.&quot;)
        self.__empname = value
* The descriptor, EmpNameDescriptor is defined to manage empname attribute. It checks if the value of empname attribute is a string or not.
class EmpIdDescriptor:
    def __get__(self, obj, owner):
        return self.__empid
    def __set__(self, obj, value):
        if hasattr(obj, &#39;empid&#39;):
            raise ValueError(&quot;&#39;empid&#39; is read only attribute&quot;)
        if not isinstance(value, int):
            raise TypeError(&quot;&#39;empid&#39; must be an integer.&quot;)
        self.__empid = value
* The descriptor, EmpIdDescriptor is defined to manage empid attribute.
class Employee:
    empid = EmpIdDescriptor()           
    empname = EmpNameDescriptor()       
    def __init__(self, emp_id, emp_name):
        self.empid = emp_id
        self.empname = emp_name
* Employee class is defined such that, it creates empid and empname attributes from descriptors EmpIdDescriptor and EmpNameDescriptor.
e1 = Employee(123456, &#39;John&#39;)
print(e1.empid, &#39;-&#39;, e1.empname)  # Output -&gt; &#39;123456 - John&#39;
e1.empid = 76347322     # Output -&gt; ValueError: &#39;empid&#39; is read only attribute
# Properties
* Descriptors can also be created using property() type.
+ Syntax:
property(fget=None, fset=None, fdel=None, doc=None)
- where,
    fget : attribute get method
    fset : attribute set method
    fdel – attribute delete method
    doc – docstring
class Employee:
    def __init__(self, emp_id, emp_name):
        self.empid = emp_id
        self.empname = emp_name
    def getEmpID(self):
        return self.__empid
    def setEmpID(self, value):
       if not isinstance(value, int):
            raise TypeError(&quot;&#39;empid&#39; must be an integer.&quot;)
        self.__empid = value
    empid = property(getEmpID, setEmpID)
# Property Decorators
* Descriptors can also be created with property decorators.
* While using property decorators, an attribute&#39;s get method will be same as its name and will be decorated with property.
* In a case of defining any set or delete methods, they will be decorated with respective setter and deleter methods.
class Employee:
    def __init__(self, emp_id, emp_name):
        self.empid = emp_id
        self.empname = emp_name
    @property
    def empid(self):
        return self.__empid
    @empid.setter
    def empid(self, value):
        if not isinstance(value, int):
            raise TypeError(&quot;&#39;empid&#39; must be an integer.&quot;)
        self.__empid = value
e1 = Employee(123456, &#39;John&#39;)
print(e1.empid, &#39;-&#39;, e1.empname)    # Output -&gt; &#39;123456 - John&#39;
# Introduction to Class and Static Methods
Based on the **scope**, functions/methods are of two types. They are:
* Class methods
* Static methods
# Class Methods
* A method defined inside a class is bound to its object, by default.
* However, if the method is bound to a Class, then it is known as **classmethod**.
class Circle(object):
    no_of_circles = 0
    def __init__(self, radius):
        self.__radius = radius
        Circle.no_of_circles += 1
    def getCirclesCount(self):
        return Circle.no_of_circles
c1 = Circle(3.5)
c2 = Circle(5.2)
c3 = Circle(4.8)
print(c1.getCirclesCount())       # -&gt; 3
print(Circle.getCirclesCount(c3)) # -&gt; 3
print(Circle.getCirclesCount())   # -&gt; TypeError: getCirclesCount() missing 1 required positional argument: &#39;self&#39;
class Circle(object):
    no_of_circles = 0
    def __init__(self, radius):
        self.__radius = radius
        Circle.no_of_circles += 1
    @classmethod
    def getCirclesCount(self):
        return Circle.no_of_circles
c1 = Circle(3.5)           
c2 = Circle(5.2)           
c3 = Circle(4.8)           
print(c1.getCirclesCount())       # -&gt; 3
print(Circle.getCirclesCount())   # -&gt; 3
# Static Method
* A method defined inside a class and not bound to either a class or an object is known as **Static** Method.
* Decorating a method using **@staticmethod** decorator makes it a static method.
def square(x):
        return x**2
class Circle(object):
    def __init__(self, radius):
        self.__radius = radius
    def area(self):
        return 3.14*square(self.__radius)
c1 = Circle(3.9)
print(c1.area())       # -&gt; 47.7594
print(square(10))      # -&gt; 100
* square function is not packaged properly and does not appear as integral part of class Circle.
class Circle(object):
    def __init__(self, radius):
        self.__radius = radius
    @staticmethod
    def square(x):
        return x**2
    def area(self):
        return 3.14*self.square(self.__radius)
c1 = Circle(3.9)
print(c1.area())  # -&gt; 47.7594
print(square(10)) # -&gt; NameError: name &#39;square&#39; is not defined
* square method is no longer accessible from outside the class Circle.
* However, it is possible to access the static method using Class or the Object as shown below.
print(Circle.square(10)) # -&gt; 100
print(c1.square(10))     # -&gt; 100
# Abstract Base Classes
* An **Abstract Base Class** or **ABC** mandates the derived classes to implement specific methods from the base class.
* It is not possible to create an object from a defined ABC class.
* Creating objects of derived classes is possible only when derived classes override existing functionality of all abstract methods defined in an ABC class.
* In Python, an Abstract Base Class can be created using module abc.
from abc import ABC, abstractmethod
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    @abstractmethod
    def perimeter(self):
        pass
* Abstract base class Shape is defined with two abstract methods area and perimeter.
class Circle(Shape):
    def __init__(self, radius):
        self.__radius = radius
    @staticmethod
    def square(x):
        return x**2
    def area(self):
        return 3.14*self.square(self.__radius)
    def perimeter(self):
        return 2*3.14*self.__radius
c1 = Circle(3.9)
print(c1.area())   # -&gt; 47.7594
# Context Manager
* A Context Manager allows a programmer to perform required activities, automatically, while entering or exiting a Context.
* For example, opening a file, doing few file operations, and closing the file is manged using Context Manager as shown below.
with open(&#39;sample.txt&#39;, &#39;w&#39;) as fp:
    content = fp.read()
* The keyword **with** is used in Python to enable a context manager. It automatically takes care of closing the file.
import sqlite3
class DbConnect(object):
    def __init__(self, dbname):
        self.dbname = dbname
    def __enter__(self):
        self.dbConnection = sqlite3.connect(self.dbname)
        return self.dbConnection
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.dbConnection.close()
with DbConnect(&#39;TEST.db&#39;) as db:
    cursor = db.cursor()
    &#39;&#39;&#39;
   Few db operations
   ...
    &#39;&#39;&#39;
* Example
from contextlib import contextmanager
@contextmanager
def context():
    print(&#39;Entering Context&#39;)
    yield 
    print(&quot;Exiting Context&quot;)

with context():
    print(&#39;In Context&#39;)
# Output -&gt; Entering Context -&gt; In Context -&gt; Exiting Context
# Coroutines
* A Coroutine is **generator** which is capable of constantly receiving input data, process input data and may or may not return any output.
* Coroutines are majorly used to build better **Data Processing Pipelines**.
* Similar to a generator, execution of a coroutine stops when it reaches **yield** statement.
* A Coroutine uses **send** method to send any input value, which is captured by yield expression.
def TokenIssuer():
    tokenId = 0
    while True:
        name = yield
        tokenId += 1
        print(&#39;Token number of&#39;, name, &#39;:&#39;, tokenId)
t = TokenIssuer()
next(t)
t.send(&#39;George&#39;)  # -&gt; Token number of George: 1
t.send(&#39;Rosy&#39;)    # -&gt; Token number of Rosy: 2
* **TokenIssuer** is a coroutine function, which uses yield to accept name as input.
* Execution of coroutine function begins only when next is called on coroutine t.
* This results in the execution of all the statements till a yield statement is encountered.
* Further execution of function resumes when an input is passed using send, and processes all statements till next yield statement.
def TokenIssuer(tokenId=0):
    try:
       while True:
            name = yield
            tokenId += 1
            print(&#39;Token number of&#39;, name, &#39;:&#39;, tokenId)
    except GeneratorExit:
        print(&#39;Last issued Token is :&#39;, tokenId)
t = TokenIssuer(100)
next(t)
t.send(&#39;George&#39;) # Token number of George: 101
t.send(&#39;Rosy&#39;)   # Token number of Rosy: 102
t.send(&#39;Smith&#39;)  # Token number of Smith: 103
t.close()        # Last issued Token is: 103
* The coroutine function TokenIssuer takes an argument, which is used to set a starting number for tokens.
* When coroutine t is closed, statements under GeneratorExit block are executed.
* Many programmers may forget that passing input to coroutine is possible only after the first next function call, which results in error.
* Such a scenario can be avoided using a decorator.
def coroutine_decorator(func):
    def wrapper(*args, **kwdargs):
        c = func(*args, **kwdargs)
        next(c)
        return c
    return wrapper
@coroutine_decorator
def TokenIssuer(tokenId=0):
    try:
        while True:
            name = yield
            tokenId += 1
            print(&#39;Token number of&#39;, name, &#39;:&#39;, tokenId)
    except GeneratorExit:
        print(&#39;Last issued Token is :&#39;, tokenId)
t = TokenIssuer(100)
t.send(&#39;George&#39;)
t.send(&#39;Rosy&#39;)
t.send(&#39;Smith&#39;)
t.close()
* coroutine_decorator takes care of calling next on the created coroutine t.
def nameFeeder():
    while True:
        fname = yield
        print(&#39;First Name:&#39;, fname)
        lname = yield
        print(&#39;Last Name:&#39;, lname)

n = nameFeeder()
next(n)
n.send(&#39;George&#39;)
n.send(&#39;Williams&#39;)
n.send(&#39;John&#39;)
First Name: George
Last Name: Williams
First Name: John
</pre></div>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2018 - 2019 Leslie
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>